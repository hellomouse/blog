import js, {
  ArrayPattern,
  ArrowFunctionExpression,
  AssignmentPattern,
  Expression as BabelExpression,
  ExpressionStatement as BabelExpressionStatement,
  File as BabelFile,
  Node as BabelNode,
  Declaration,
  Identifier,
  ImportDeclaration,
  JSXAttribute,
  JSXElement,
  JSXExpressionContainer,
  JSXFragment,
  JSXIdentifier,
  JSXMemberExpression,
  JSXNamespacedName,
  JSXSpreadAttribute,
  JSXText,
  ObjectPattern,
  ObjectProperty,
  Program,
  RestElement,
  SourceLocation,
} from '@babel/types';
import {
  ExpressionStatement as EstreeExpressionStatement,
  Node as EstreeNode,
  Program as EstreeProgram,
} from 'estree';
import _estreeToBabel from 'estree-to-babel';
import { BlockContent, Definition, DefinitionContent, Nodes as MdastNode, Parents, PhrasingContent, TableRow } from 'mdast';
import { MdxJsxAttribute, MdxJsxExpressionAttribute } from 'mdast-util-mdx-jsx';
import assert from 'node:assert/strict';
import { Position as UnistPosition } from 'unist';
import { AbstractNodeTransformer, AbstractTransformGenerator, AbstractTransformer } from './tree-transformer.js';

export interface Context {
  current: MdastNode;
  identifiers: Set<string>;
  nextDisambiguationIndex: () => number;
  definitions: Map<string, Definition>;
  references: Map<string, ApplyDefinition[]>;
  addReference: (identifier: string, reference: ApplyDefinition) => void;
  handleFrontmatter: (data: string) => void;
  headingStack: HeadingInfo[][];
  headingCounters: number[];
  headingComponents: Record<string, ArrowFunctionExpression>;
  nextFootnoteIndex: () => number;
  footnoteComponents: Record<string, [number, ArrowFunctionExpression]>;
  footnoteIndexes: Map<string, number>;
  nonContainerDirectiveHandlers: Map<string, NonContainerDirectiveProcessor>;
  containerDirectiveHandlers: Map<string, ContainerDirectiveProcessor>;
  imports: ImportDeclaration[];
  exports: ObjectProperty[];
  exportDeclarations: Declaration[];
}

export type ApplyDefinition = (definition: Definition) => void;

export interface HeadingInfo {
  /** null if autogenerated invalid heading */
  identifier: string | null;
  counters: number[];
  children?: HeadingInfo[];
}

// of note: MDX does not support JSXSpreadChild syntax (<a>{...stuff}</a>)
export type JSXNode = JSXText | JSXExpressionContainer | JSXElement | JSXFragment;
export type VisitorGenerator = AbstractTransformGenerator<MdastNode, JSXNode>;
export type NodeVisitor = AbstractNodeTransformer<MdastNode, JSXNode, Context>;

export interface DirectiveProcessor {
  context: Context;
  type: string;
  name: string;
  attributes: Record<string, string>;
  position?: UnistPosition;
}

export interface NonContainerDirectiveInfo extends DirectiveProcessor {
  type: 'text' | 'leaf';
  children: PhrasingContent[];
};

export interface ContainerDirectiveInfo extends DirectiveProcessor {
  type: 'container';
  label: PhrasingContent[] | null;
  children: (BlockContent | DefinitionContent)[];
}

export type NonContainerDirectiveProcessor = (directive: NonContainerDirectiveInfo) => VisitorGenerator;
export type ContainerDirectiveProcessor = (directive: ContainerDirectiveInfo) => VisitorGenerator;

export class JSXTransform extends AbstractTransformer<MdastNode, JSXNode, Context> {
  /** Set of currently existing identifiers */
  public identifiers!: Set<string>;
  /** The disambiguation index is appended to identifiers if they are duplicate */
  public _disambiguationIndex!: number;
  /** Resource definitions */
  public _definitions!: Map<string, Definition>;
  /** Nodes referencing definitions */
  public _references!: Map<string, ApplyDefinition[]>;
  /** Metadata preceding document */
  public frontmatter!: string | null;
  /** Heading components */
  public headingComponents!: Record<string, ArrowFunctionExpression>;
  /** Heading stack (not to be confused with the heading tree) */
  public _headingStack!: HeadingInfo[][];
  /** Heading counters stack */
  public _headingCounters!: number[];
  /** Heading tree */
  public headingTree!: HeadingInfo[];
  /** Footnote components: [index, component] */
  public footnoteComponents!: Record<string, [number, ArrowFunctionExpression]>;
  /** Footnote identifier to index */
  public _footnoteIndexes!: Map<string, number>;
  /** Current footnote index */
  public _footnoteCounter!: number;
  /** Import declarations */
  public imports!: ImportDeclaration[];
  /** Exported values */
  public exports!: ObjectProperty[];
  /** Export declarations */
  public exportDeclarations!: Declaration[];
  /** If transform should call reset */
  public _needsReset!: boolean;

  constructor(
    /** Registered visitors */
    public visitors: Map<MdastNode['type'], NodeVisitor>,
    /** Handlers for non-container (text, leaf) directives */
    public nonContainerDirectiveHandlers: Map<string, NonContainerDirectiveProcessor>,
    /** Handlers for container directives */
    public containerDirectiveHandlers: Map<string, ContainerDirectiveProcessor>,
  ) {
    super();
    this.reset();
  }

  reset() {
    this.identifiers = new Set();
    this._disambiguationIndex = 2;
    this._definitions = new Map();
    this._references = new Map();
    this.frontmatter = null;
    this.headingComponents = {};
    this._headingStack = [];
    this._headingCounters = [];
    this.headingTree = [];
    this.footnoteComponents = {};
    this._footnoteIndexes = new Map();
    this._footnoteCounter = 1;
    this.imports = [];
    this.exports = [];
    this.exportDeclarations = [];
    this._needsReset = false;
  }

  makeContext(node: MdastNode): Context {
    // TODO: recycle this?
    let self = this;
    return {
      current: node,
      identifiers: self.identifiers,
      nextDisambiguationIndex() {
        return self._disambiguationIndex++;
      },
      definitions: self._definitions,
      references: self._references,
      addReference(identifier, reference) {
        let list = self._references.get(identifier);
        if (!list) {
          self._references.set(identifier, [reference]);
        } else {
          list.push(reference);
        }
      },
      handleFrontmatter(data) {
        self.frontmatter = data;
      },
      headingStack: self._headingStack,
      headingCounters: self._headingCounters,
      headingComponents: self.headingComponents,
      nextFootnoteIndex() {
        return self._footnoteCounter++;
      },
      footnoteComponents: self.footnoteComponents,
      footnoteIndexes: self._footnoteIndexes,
      nonContainerDirectiveHandlers: self.nonContainerDirectiveHandlers,
      containerDirectiveHandlers: self.containerDirectiveHandlers,
      imports: self.imports,
      exports: self.exports,
      exportDeclarations: self.exportDeclarations,
    };
  }

  getTransform(node: MdastNode): NodeVisitor {
    let visitor = this
    .visitors.get(node.type);
    if (!visitor) {
      throw new Error('unhandled node type: ' + node.type);
    }
    return visitor;
  }

  transformTree(root: MdastNode): JSXNode {
    if (this._needsReset) this.reset();
    this._needsReset = true;

    let out = super.transformTree(root);

    // resolve references
    for (let [identifier, definition] of this._definitions.entries()) {
      let matching = this._references.get(identifier);
      if (!matching) {
        console.error(`warning: found dangling definition ${identifier}`);
        continue;
      }

      for (let callback of matching) {
        callback(definition);
      }
    }

    // flush heading stack
    while (this._headingStack.length > 1) {
      let previous = this._headingStack.pop()!;
      let top = this._headingStack[this._headingStack.length - 1];
      let last = top[top.length - 1];
      last.children = previous;
    }

    this.headingTree = this._headingStack[0] ?? [];

    // resolve footnote indexes
    for (let [key, index] of this._footnoteIndexes) {
      this.footnoteComponents[key][0] = index;
    }
  
    return out;
  }
}

export const CONTEXT_VAR = '_$ctx';
export const CONTEXT_COMPONENTS = 'el';

export function estreeToBabel(input: EstreeNode): BabelNode {
  // estree-to-babel expects a File
  // node module typing weirdness
  return (_estreeToBabel as any)({
    type: 'File',
    program: input
  }).program;
}

export function convertLocation(position: UnistPosition): SourceLocation {
  // offset -> position
  // columns are zero-indexed in babel but one-indexed in mdast
  return {
    start: { line: position.start.line, column: position.start.column - 1, index: position.start.offset! },
    end: { line: position.end.line, column: position.end.column - 1, index: position.end.offset! },
  } as SourceLocation;
}

export function copyLoc(from: { position?: UnistPosition | null }, to: { loc?: SourceLocation | null }) {
  if (from.position) to.loc = convertLocation(from.position);
}

export function convertJsxExpressionBody(estree: EstreeProgram): JSXExpressionContainer {
  assert(estree.type === 'Program');
  // need this to preserve comments
  let converted = (_estreeToBabel as any)(estree) as BabelFile;
  let container;
  if (converted.program.body.length === 1) {
    assert(converted.program.body[0].type === 'ExpressionStatement');
    // types don't expect expression parse mode
    let expr = (converted.program.body[0] as BabelExpressionStatement).expression;
    container = js.jsxExpressionContainer(expr);
  } else if (estree.comments?.length) {
    container = js.jsxExpressionContainer(js.jsxEmptyExpression());
  } else {
    throw new Error('unexpected JSX empty block');
  }
  if (converted.comments?.length) {
    // relocate comments
    container.expression.leadingComments = converted.comments;
  }
  return container;
}

/** Create one of the JSX name nodes from a string name */
export function makeJsxName(name: string, allowMember?: true): JSXIdentifier | JSXMemberExpression | JSXNamespacedName
export function makeJsxName(name: string, allowMember: false): JSXIdentifier | JSXNamespacedName
export function makeJsxName(name: string, allowMember = true): JSXIdentifier | JSXMemberExpression | JSXNamespacedName {
  if (name.includes('.')) {
    if (!allowMember) {
      throw new Error('JSX member expression cannot occur in the current position');
    }
    let components = name.split('.');
    assert(components.length >= 2);
    let obj = js.jsxMemberExpression(
      js.jsxIdentifier(components.shift()!),
      js.jsxIdentifier(components.shift()!),
    );
    while (components.length) {
      obj = js.jsxMemberExpression(obj, js.jsxIdentifier(components.shift()!));
    }
    return obj;
  } else if (name.includes(':')) {
    let components = name.split(':');
    assert(components.length === 2);
    return js.jsxNamespacedName(
      js.jsxIdentifier(components[0]),
      js.jsxIdentifier(components[1]),
    );
  } else {
    return js.jsxIdentifier(name);
  }
}

export function makeContextComponentName(name: string): JSXMemberExpression {
  return js.jsxMemberExpression(
    js.jsxMemberExpression(
      js.jsxIdentifier(CONTEXT_VAR),
      js.jsxIdentifier(CONTEXT_COMPONENTS)
    ),
    js.jsxIdentifier(name)
  );
}

export function makeJsxFragment(children: JSXNode | JSXNode[]): JSXFragment {
  if (!Array.isArray(children)) {
    children = [children];
  }
  return js.jsxFragment(
    js.jsxOpeningFragment(),
    js.jsxClosingFragment(),
    children,
  );
}

/**
 * Create a JSX tag
 * @param name Name of tag, either a string or a JSX name
 * @param attributes JSX attributes
 * @param children Children, or null for a self-closing tag
 * @returns Created tag
 */
export function makeJsxElement(
  name: JSXIdentifier | JSXMemberExpression | JSXNamespacedName | string,
  attributes: (JSXAttribute | JSXSpreadAttribute)[],
  children: JSXNode | JSXNode[] | null
): JSXElement {
  let jsxName;
  if (typeof name === 'string') {
    jsxName = makeJsxName(name);
  } else {
    jsxName = name;
  }
  let selfClosing = children === null;
  let openingElement = js.jsxOpeningElement(jsxName, attributes, selfClosing);
  if (selfClosing) {
    return js.jsxElement(openingElement, null, [], true);
  } else {
    let closingElement = js.jsxClosingElement(jsxName);
    if (!Array.isArray(children)) {
      children = [children!];
    }
    return js.jsxElement(openingElement, closingElement, children, false);
  }
}

export function* applySimpleElement(context: Context, nodeType: Parents['type'], elementType: string): VisitorGenerator {
  let node = context.current;
  assert(node.type === nodeType);
  let out = makeJsxElement(js.jsxIdentifier(elementType), [], yield node.children);
  copyLoc(node, out);
  return [out];
}

/** Attempt to convert a subtree to a string */
export function contentToText(contents: PhrasingContent[]): string {
  let out = [];
  for (let content of contents) {
    let stack = [content];
    while (stack.length) {
      let next = stack.pop()!;
      if (next.type === 'text' || next.type === 'inlineCode') {
        out.push(next.value);
      } else if ('children' in next && Array.isArray(next.children)) {
        let children = next.children;
        for (let i = children.length - 1; i >= 0; i--) {
          stack.push(children[i]);
        }
      }
    }
  }
  return out.join('');
}

export function convertMdxJsxAttribute(node: MdxJsxAttribute | MdxJsxExpressionAttribute): JSXAttribute | JSXSpreadAttribute {
  if (node.type === 'mdxJsxAttribute') {
    let jsxName = makeJsxName(node.name, false);
    if (typeof node.value === 'undefined' || node.value === null) {
      let out = js.jsxAttribute(jsxName, null);
      copyLoc(node, out);
      return out;
    } else if (typeof node.value === 'string') {
      let out = js.jsxAttribute(jsxName, js.stringLiteral(node.value));
      copyLoc(node, out);
      return out;
    } else if (node.value.type === 'mdxJsxAttributeValueExpression') {
      let expression = convertJsxExpressionBody(node.value.data!.estree!);
      let out = js.jsxAttribute(jsxName, expression);
      copyLoc(node, out);
      return out;
    } else {
      throw new Error('unreachable');
    }
  } else if (node.type === 'mdxJsxExpressionAttribute') {
    // spread expressions only
    let expression = (node.data?.estree?.body?.[0] as EstreeExpressionStatement)?.expression;
    assert(expression?.type === 'ObjectExpression');
    let spreadElement = expression.properties[0];
    assert(spreadElement.type === 'SpreadElement');
    let spreadExpr = estreeToBabel(spreadElement.argument);
    let out = js.jsxSpreadAttribute(spreadExpr as BabelExpression);
    copyLoc(node, out);
    return out;
  } else {
    throw new Error('bad node type');
  }
}

export function* convertMdxExpression(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'mdxFlowExpression' || node.type === 'mdxTextExpression');
  let out = convertJsxExpressionBody(node.data!.estree!);
  copyLoc(node, out);
  return [out];
}

export function* convertJsxElement(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'mdxJsxFlowElement' || node.type === 'mdxJsxTextElement');

  if (!node.name) {
    // handle fragment
    let fragment = makeJsxFragment(yield node.children);
    copyLoc(node, fragment);
    return [fragment];
  }

  let jsxName = makeJsxName(node.name);
  // assume self-closing if no children
  let selfClosing = node.children.length === 0;
  let attributes = node.attributes.map(convertMdxJsxAttribute);
  let openingElement = js.jsxOpeningElement(jsxName, attributes, selfClosing);

  if (selfClosing) {
    let out = js.jsxElement(openingElement, null, [], true);
    copyLoc(node, out);
    return [out];
  } else {
    let closingElement = js.jsxClosingElement(jsxName);
    let children = yield node.children;
    assert(Array.isArray(children));
    let out = js.jsxElement(openingElement, closingElement, children, false);
    copyLoc(node, out);
    return [out];
  }
}

export function* convertList(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'list');

  let elementName;
  let attributes = [];
  if (node.ordered) {
    elementName = js.jsxIdentifier('ol');
    if (typeof node.start === 'number' && node.start !== 1) {
      attributes.push(js.jsxAttribute(
        js.jsxIdentifier('start'),
        js.jsxExpressionContainer(js.numericLiteral(node.start))
      ));
    }
  } else {
    elementName = js.jsxIdentifier('ul');
  }

  let children: JSXElement[] = [];
  for (let listItem of node.children) {
    let itemChildren: MdastNode[];
    if (!node.spread) {
      // tight lists should not generate paragraphs, see <https://spec.commonmark.org/0.30/#loose>
      itemChildren = listItem.children.flatMap<MdastNode>(node => {
        if (node.type === 'paragraph') {
          return node.children;
        } else {
          return node;
        }
      });
    } else {
      itemChildren = listItem.children;
    }
    let liElement = makeJsxElement('li', [], yield itemChildren);
    copyLoc(listItem, liElement);
    children.push(liElement);
  }

  let out = makeJsxElement(elementName, attributes, children);
  copyLoc(node, out);
  return [out];
}

export function* convertBlockquote(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'blockquote');
  let jsxName = makeContextComponentName('Blockquote');
  let out = makeJsxElement(jsxName, [], yield node.children);
  copyLoc(node, out);
  return [out];
}

export function* convertTable(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'table');
  assert(node.children.length >= 2);
  assert(node.align, 'expected table node to have alignment information');
  let align = node.align;
  
  function* processRow(rowNode: TableRow, isHeading: boolean): Generator<MdastNode[], JSXNode, JSXNode[]> {
    let cells = [];
    for (let [index, cellNode] of rowNode.children.entries()) {
      let cellAttributes = [];
      if (align[index]) {
        cellAttributes.push(
          js.jsxAttribute(js.jsxIdentifier('style'), js.stringLiteral(`text-align: ${align[index]}`))
        );
      }
      let cell = makeJsxElement(isHeading ? 'th' : 'td', cellAttributes, yield cellNode.children);
      copyLoc(cellNode, cell);
      cells.push(cell);
    }
    let row = makeJsxElement('tr', [], cells);
    copyLoc(rowNode, row);
    return row;
  }

  let headRow = node.children[0];
  let thead = makeJsxElement('thead', [], yield* processRow(headRow, true));
  let bodyRows = node.children.slice(1);
  let body: JSXNode[] = [];
  for (let row of bodyRows) {
    body.push(yield* processRow(row, false));
  }
  let tbody = makeJsxElement('tbody', [], body);

  let out = makeJsxElement('table', [], [thead, tbody]);
  copyLoc(node, out);
  return [out];
}

export function* convertCode(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'code');
  let jsxName = makeContextComponentName('Code');
  let attributes = [];
  if (node.lang) {
    attributes.push(js.jsxAttribute(js.jsxIdentifier('lang'), js.stringLiteral(node.lang)));
  }
  if (node.meta) {
    attributes.push(js.jsxAttribute(js.jsxIdentifier('meta'), js.stringLiteral(node.meta)));
  }
  let content = js.jsxExpressionContainer(js.stringLiteral(node.value));
  let out = makeJsxElement(jsxName, attributes, content);
  copyLoc(node, out);
  return [out];
}

export function* convertBlockMath(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'math');
  let jsxName = makeContextComponentName('Math');
  let attributes = [
    js.jsxAttribute(js.jsxIdentifier('type'), js.stringLiteral('block'))
  ];
  if (node.meta) {
    attributes.push(
      js.jsxAttribute(js.jsxIdentifier('meta'), js.stringLiteral(node.meta))
    );
  }
  let content = js.jsxExpressionContainer(js.stringLiteral(node.value));
  let out = makeJsxElement(jsxName, attributes, content);
  copyLoc(node, out);
  return [out];
}

export function* convertInlineMath(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'inlineMath');
  let jsxName = makeContextComponentName('Math');
  let attributes = [
    js.jsxAttribute(js.jsxIdentifier('type'), js.stringLiteral('inline'))
  ];
  let content = js.jsxExpressionContainer(js.stringLiteral(node.value));
  let out = makeJsxElement(jsxName, attributes, content);
  copyLoc(node, out);
  return [out];
}

export function* convertHeading(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'heading');
  let jsxName = makeContextComponentName('Heading');
  let identifier: string;

  if (node.name) {
    if (context.identifiers.has(node.name)) {
      throw new Error('duplicate heading identifier name: ' + node.name);
    } else {
      identifier = node.name;
    }
  } else {
    let baseIdentifier = 'heading-' + contentToText(node.children)
      .toLowerCase()
      .replace(/\s+/g, '-')
      .replace(/[^\w\-_]/g, '');
    identifier = baseIdentifier;

    while (context.identifiers.has(identifier)) {
      // disambiguate...
      identifier = `${baseIdentifier}-${context.nextDisambiguationIndex()}`;
    }
  }

  context.identifiers.add(identifier);

  let stack = context.headingStack;
  let counters = context.headingCounters;
  // update heading tree
  while (stack.length > node.depth) {
    // commit trees
    let subtree = stack.pop()!;
    counters.pop();
    let top = stack[stack.length - 1];
    let last = top[top.length - 1];
    assert(!last.children);
    last.children = subtree;
  }
  while (stack.length < node.depth - 1) {
    // missing intermediate headings, pad to depth
    counters.push(0);
    stack.push([{ identifier: null, counters: counters.slice() }]);
  }
  if (stack.length === node.depth - 1) {
    // push new entry
    counters.push(1);
    stack.push([{ identifier, counters: counters.slice() }]);
  } else {
    // add to existing
    counters[counters.length - 1]++;
    let top = stack[stack.length - 1];
    top.push({ identifier, counters: counters.slice() });
  }

  let component = js.arrowFunctionExpression([], makeJsxFragment(yield node.children));
  context.headingComponents[identifier] = component;

  let attributes = [
    js.jsxAttribute(
      js.jsxIdentifier('depth'),
      js.jsxExpressionContainer(js.numericLiteral(node.depth))
    ),
    js.jsxAttribute(js.jsxIdentifier('identifier'), js.stringLiteral(identifier))
  ];
  let out = makeJsxElement(jsxName, attributes, null);
  copyLoc(node, out);
  return [out];
}

export function* convertInlineCode(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'inlineCode');
  let content = js.jsxExpressionContainer(js.stringLiteral(node.value));
  let out = makeJsxElement('code', [], content);
  copyLoc(node, out);
  return [out];
}

export function* convertParagraph(context: Context): VisitorGenerator {
  return yield* applySimpleElement(context, 'paragraph', 'p');
}

export function* convertEmphasis(context: Context): VisitorGenerator {
  return yield* applySimpleElement(context, 'emphasis', 'em');
}

export function* convertStrong(context: Context): VisitorGenerator {
  return yield* applySimpleElement(context, 'strong', 'strong');
}

export function* convertStrikethrough(context: Context): VisitorGenerator {
  return yield* applySimpleElement(context, 'delete', 's');
}

export function* convertDefinition(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'definition');
  if (context.definitions.has(node.identifier)) {
    throw new Error('duplicate definition: ' + node.identifier);
  }
  context.definitions.set(node.identifier, node);

  // no value
  return [];
}

export function* convertLink(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'link');
  let attributes = [
    js.jsxAttribute(js.jsxIdentifier('href'), js.stringLiteral(node.url))
  ];
  if (node.title) {
    attributes.push(
      js.jsxAttribute(js.jsxIdentifier('title'), js.stringLiteral(node.title))
    );
  }
  let out = makeJsxElement('a', attributes, yield node.children);
  copyLoc(node, out);
  return [out];
}

export function* convertImage(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'image');
  let attributes = [
    js.jsxAttribute(js.jsxIdentifier('src'), js.stringLiteral(node.url))
  ];
  if (node.title) {
    attributes.push(
      js.jsxAttribute(js.jsxIdentifier('title'), js.stringLiteral(node.title))
    );
  }
  if (node.alt) {
    attributes.push(
      js.jsxAttribute(js.jsxIdentifier('alt'), js.stringLiteral(node.alt))
    );
  }
  let out = makeJsxElement(makeContextComponentName('Image'), attributes, null);
  copyLoc(node, out);
  return [out];
}

export function* convertLinkReference(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'linkReference');
  let out = makeJsxElement('a', [], yield node.children);
  copyLoc(node, out);
  let attributes = out.openingElement.attributes;
  context.addReference(node.identifier, definition => {
    attributes.push(
      js.jsxAttribute(js.jsxIdentifier('href'), js.stringLiteral(definition.url))
    );
    if (definition.title) {
      attributes.push(
        js.jsxAttribute(js.jsxIdentifier('title'), js.stringLiteral(definition.title))
      );
    }
  });
  return [out];
}

export function* convertImageReference(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'imageReference');
  let out = makeJsxElement(makeContextComponentName('Image'), [], null);
  copyLoc(node, out);
  let attributes = out.openingElement.attributes;
  if (node.alt) {
    attributes.push(
      js.jsxAttribute(js.jsxIdentifier('alt'), js.stringLiteral(node.alt))
    );
  }
  context.addReference(node.identifier, definition => {
    attributes.push(
      js.jsxAttribute(js.jsxIdentifier('src'), js.stringLiteral(definition.url))
    );
    if (definition.title) {
      attributes.push(
        js.jsxAttribute(js.jsxIdentifier('title'), js.stringLiteral(definition.title))
      );
    }
  });
  return [out];
}

export function* convertFootnoteDefinition(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'footnoteDefinition');
  
  let identifier = node.identifier;
  if (identifier in context.footnoteComponents) {
    throw new Error('duplicate footnote identifier: ' + identifier);
  }
  let defId = `footnote-def-${identifier}`;
  let refId = `footnote-ref-${identifier}`;
  if (context.identifiers.has(defId)) {
    throw new Error('footnote identifier collides: ' + defId);
  }
  if (context.identifiers.has(refId)) {
    throw new Error('footnote identifier collides: ' + refId);
  }
  context.identifiers.add(defId);
  context.identifiers.add(refId);

  let component = js.arrowFunctionExpression([], makeJsxFragment(yield node.children));
  copyLoc(node, component);
  // index resolved later
  context.footnoteComponents[identifier] = [-1, component];

  return [];
}

export function* convertFootnoteReference(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'footnoteReference');

  let identifier = node.identifier;
  let index = context.footnoteIndexes.get(identifier);
  // indexes can't be 0 because they start at 1
  if (!index) {
    index = context.nextFootnoteIndex();
    context.footnoteIndexes.set(identifier, index);
  }

  let jsxName = makeContextComponentName('Footnote');
  let attributes = [
    js.jsxAttribute(js.jsxIdentifier('identifier'), js.stringLiteral(identifier)),
    js.jsxAttribute(
      js.jsxIdentifier('index'),
      js.jsxExpressionContainer(js.numericLiteral(index))
    )
  ];
  let out = makeJsxElement(jsxName, attributes, null);
  copyLoc(node, out);
  return [out];
}

export function* convertThematicBreak(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'thematicBreak');
  let out = makeJsxElement('hr', [], null);
  copyLoc(node, out);
  return [out];
}

export function* convertText(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'text');

  if (node.value.match(/^[\w\s+\-/\.,?!@#$%():;'"]*$/)) {
    // "simple" text, emit JSXText to prevent clutter
    // TODO: is that regex safe?
    let out = js.jsxText(node.value);
    // needed by dom-expressions. we can (probably) safely put our value as raw due to regex
    out.extra = { raw: node.value };
    copyLoc(node, out);
    return [out];
  } else {
    // wrap in string literal
    let out = js.jsxExpressionContainer(js.stringLiteral(node.value));
    copyLoc(node, out);
    return [out];
  }
}

export function* convertBreak(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'break');
  let out = makeJsxElement('br', [], null);
  copyLoc(node, out);
  return [out];
}

export function* convertRoot(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'root');
  let out = makeJsxFragment(yield node.children);
  copyLoc(node, out);
  return [out];
}

export function* convertFrontmatter(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'yaml');
  context.handleFrontmatter(node.value);
  return [];
}

export function* convertTextDirective(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'textDirective');
  if (!node.attributes) {
    throw new Error('expected attributes');
  }
  let processor = context.nonContainerDirectiveHandlers.get(node.name);
  if (!processor) {
    throw new Error(`no handler found for ${node.type} directive "${node.name}"`);
  }

  return yield* processor({
    context,
    name: node.name,
    type: 'text',
    attributes: node.attributes as Record<string, string>,
    children: node.children,
    position: node.position,
  });
}

export function* convertLeafDirective(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'leafDirective');
  if (!node.attributes) {
    throw new Error('expected attributes');
  }
  let processor = context.nonContainerDirectiveHandlers.get(node.name);
  if (!processor) {
    throw new Error(`no handler found for ${node.type} directive "${node.name}"`);
  }

  return yield* processor({
    context,
    name: node.name,
    type: 'leaf',
    attributes: node.attributes as Record<string, string>,
    children: node.children,
    position: node.position,
  });
}

export function* convertContainerDirective(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'containerDirective');
  if (!node.attributes) {
    throw new Error('expected attributes');
  }
  let processor = context.containerDirectiveHandlers.get(node.name);
  if (!processor) {
    throw new Error(`no handler found for ${node.type} directive "${node.name}"`);
  }

  let label: PhrasingContent[] | null = null;
  let children = node.children;
  if (children?.[0]?.type === 'paragraph' && children[0].data?.directiveLabel) {
    // handle label
    label = children[0].children;
    children = node.children.slice(1);
  }

  return yield* processor({
    context,
    name: node.name,
    type: 'container',
    attributes: node.attributes as Record<string, string>,
    label,
    children,
    position: node.position,
  });
}

export type DestructureNodes = ObjectPattern | ArrayPattern | AssignmentPattern | RestElement | Identifier;

/** Class that turns a destructure pattern into a list of identifiers */
export class Antidestructurer extends AbstractTransformer<DestructureNodes, null, DestructureNodes> {
  public identifiers: Identifier[] = [];

  makeContext(node: DestructureNodes): DestructureNodes {
    return node;
  }

  getTransform({ type }: DestructureNodes): AbstractNodeTransformer<DestructureNodes, null, DestructureNodes> {
    let self = this;
    switch (type) {
      case 'ObjectPattern': {
        // let { a, b: c } = value
        return function* convertObjectPattern(node) {
          node = node as ObjectPattern;
          for (let prop of node.properties) {
            let child;
            if (prop.type === 'RestElement') {
              child = yield [prop];
            } else if (prop.type === 'ObjectProperty') {
              child = yield [prop.value as DestructureNodes];
            } else {
              throw new Error('unreachable');
            }
          }
          return [null];
        }
      }
      case 'ArrayPattern': {
        // let [a, b] = value
        return function* convertArrayPattern(node) {
          node = node as ArrayPattern;
          for (let value of node.elements) {
            if (!value) continue;
            yield [value as DestructureNodes];
          }
          return [null];
        }
      }
      case 'RestElement': {
        // let [a, b, ...c] = value
        return function* convertRestElement(node) {
          node = node as RestElement;
          yield [node.argument as DestructureNodes];
          return [null];
        }
      }
      case 'AssignmentPattern': {
        // let [a = 4] = value
        return function* convertAssignmentPattern(node) {
          node = node as AssignmentPattern;
          yield [node.left as DestructureNodes];
          return [null];
        }
      }
      case 'Identifier': {
        return function* convertIdentifier(node) {
          self.identifiers.push(node as Identifier);
          return [null];
        }
      }
      default: {
        throw new Error(`unexpected node ${type} in destructuring`);
      }
    }
  }
}

export function destructureToIdentifiers(node: DestructureNodes): Identifier[] {
  let transform = new Antidestructurer();
  transform.transformTree(node);
  return transform.identifiers;
}

export function* convertMdxjsEsm(context: Context): VisitorGenerator {
  let node = context.current;
  assert(node.type === 'mdxjsEsm');
  assert(node.data?.estree);
  let program = estreeToBabel(node.data.estree) as Program;
  
  for (let stmt of program.body) {
    switch (stmt.type) {
      case 'ImportDeclaration': {
        // push import statements directly
        context.imports.push(stmt);
        break;
      }
      case 'ExportDefaultDeclaration': {
        let identDefault = js.identifier('default');
        if (js.isDeclaration(stmt.declaration)) {
          // export default function something() {}
          // export default class Something {}
          let decl = stmt.declaration;
          assert(decl.type !== 'TSDeclareFunction');
          assert(decl.id, 'declaration missing id?');

          context.exportDeclarations.push(decl);
          let property = js.objectProperty(identDefault, js.identifier(decl.id.name));
          property.loc = stmt.loc;
          context.exports.push(property);
        } else {
          // export default expr
          let property = js.objectProperty(identDefault, stmt.declaration);
          property.loc = stmt.loc;
          context.exports.push(property);
        }
        break;
      }
      case 'ExportNamedDeclaration': {
        // export { a, b, c as d }
        if (stmt.source) {
          // export { a } from 'module'
          throw new Error('"export from" statements are not supported');
        }

        if (stmt.declaration) {
          // export let name1 = expr1, name2 = expr2
          // export function doSomething() {}
          // export class Something {}
          assert(stmt.specifiers.length === 0, 'unexpected specifiers in export');
          let decl = stmt.declaration;
          
          if (decl.type === 'ClassDeclaration' || decl.type === 'FunctionDeclaration') {
            assert(decl.id, 'declaration missing id?');
            context.exportDeclarations.push(decl);
            let property = js.objectProperty(decl.id, decl.id, false, true);
            property.loc = stmt.loc;
            context.exports.push(property);
          } else if (decl.type === 'VariableDeclaration') {
            // bind exports
            for (let declarator of decl.declarations) {
              for (let identifier of destructureToIdentifiers(declarator.id as DestructureNodes)) {
                let property = js.objectProperty(identifier, identifier, false, true);
                property.loc = declarator.loc;
                context.exports.push(property);
              }
            }
            context.exportDeclarations.push(decl);           
          } else {
            throw new Error(`unexpected declaration ${decl.type} in ${stmt.type}`);
          }
        } else if (stmt.specifiers.length > 0) { 
          // export { a, b, c as d }
          // this is allowed by the parser, but only as "export let a = 4; export { a as b };"
          for (let specifier of stmt.specifiers) {
            // other types require "source"
            assert(specifier.type === 'ExportSpecifier');
            let property = js.objectProperty(specifier.exported, specifier.local);
            property.loc = specifier.loc;
            context.exports.push(property);
          }
        } else {
          throw new Error('empty export statement?');
        }
        break;
      }
      case 'ExportAllDeclaration': {
        // export * from 'module'
        throw new Error('"export from" statements are not supported');
      }
      default: {
        throw new Error('unexpected statement in mdxjsEsm node');
      }
    }
  }

  return [];
}

export function* badTree(context: Context): VisitorGenerator {
  throw new Error(`unexpected node "${context.current.type}`);
}

let visitorMap: Partial<Record<MdastNode['type'], NodeVisitor>> = {
  root: convertRoot,
  mdxFlowExpression: convertMdxExpression,
  mdxTextExpression: convertMdxExpression,
  mdxJsxFlowElement: convertJsxElement,
  mdxJsxTextElement: convertJsxElement,
  paragraph: convertParagraph,
  text: convertText,
  blockquote: convertBlockquote,
  list: convertList,
  listItem: badTree, // handled by convertList
  break: convertBreak,
  code: convertCode,
  inlineCode: convertInlineCode,
  emphasis: convertEmphasis,
  strong: convertStrong,
  delete: convertStrikethrough,
  heading: convertHeading,
  link: convertLink,
  image: convertImage,
  thematicBreak: convertThematicBreak,
  definition: convertDefinition,
  linkReference: convertLinkReference,
  imageReference: convertImageReference,
  math: convertBlockMath,
  inlineMath: convertInlineMath,
  table: convertTable,
  tableRow: badTree, // handled by table
  tableCell: badTree, // handled by table
  yaml: convertFrontmatter,
  footnoteDefinition: convertFootnoteDefinition,
  footnoteReference: convertFootnoteReference,
  textDirective: convertTextDirective,
  leafDirective: convertLeafDirective,
  containerDirective: convertContainerDirective,
  html: badTree, // disabled
  mdxjsEsm: convertMdxjsEsm,
};

export const visitors = new Map(Object.entries(visitorMap) as [MdastNode['type'], NodeVisitor][]);
